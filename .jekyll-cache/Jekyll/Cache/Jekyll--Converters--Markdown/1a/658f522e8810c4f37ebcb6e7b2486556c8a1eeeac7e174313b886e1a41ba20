I"o"<p>In (Ch-ch-) Changes, David Bowie sang “Every time I thought I’d got it made, it seemed the taste was not so sweet”, that’s a good metaphor for API design.
An API will irremediably evolve because it will lack some features or because of mistakes, and so sooner or later, you may have to introduce a “breaking change”.
That’s usually when people start to run in circle, scream and shout “Oh! Please no! Please, not a breaking ch-ch-change”.
But, what is it actually? How to handle it? And should you always be afraid of it?</p>

<!--more-->

<h1 id="what-is-a-breaking-change">What is a breaking change</h1>

<p>A breaking change is non backward-compatible modification that requires consumers to modify their code in order to continue using an API (or at least modify the part of their code using the modified part of the API).
There are many different ways to introduce breaking changes in APIs, some are obvious, some are not.</p>

<p>The most common obvious way to introduce a breaking change is to rename or remove something in the interface contract.
Rename <code>GET /usrs</code> to <code>GET /users</code> or remove the <code>isAdmin</code> property from the User data model and there’s a huge risk that it will break some if not all of the API’s consumers.
There are also less obvious interface contract’s breaking changes. Turning an optional parameter into a required one or adding new values to enumerations that consumer is supposed to interpret. And there are even less obvious and far more treacherous breaking changes:</p>

<blockquote class="blockquote">
    <p class="mb-0">With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody.</p><footer class="blockquote-footer">
        <cite title="Source Title"><a href="https://www.hyrumslaw.com/">Hyrum Wright, Hyrum's Law</a></cite>
    </footer></blockquote>

<div class="image ">
    <figure class="figure">
        <img src="/images/handling-breaking-ch-ch-changes/xkcd.png" class="figure-img img-fluid" /><figcaption class="figure-caption"><a href="https://xkcd.com/1172/">XKCD: Workflow</a></figcaption></figure>
</div>

<p>A breaking change can happen without actually modifying the API’s interface contract.
Change a business rule so that given the same conditions a user’s “asshole level” is set to orange instead of green when analyzing their last comments and that may break something. 
Pushing the concept to the extreme, that also means some consumers could depend on an API’s long response time and optimizing the API’s implementation to make things go faster on provider’s side could put them at risk.
That’s probably going a little bit too far, but keep that in mind, just in case.</p>

<p>So a breaking change is a change that could literally break something on the consumer side.
That does not sound good but is it actually always that bad?</p>

<h1 id="evaluating-the-cost-of-breaking-change">Evaluating the cost of breaking change</h1>

<p>As an architect, my favorite answer to any question is “it depends”.
And in that case, it applies yet another time.
Depending on the context, the cost of a breaking change vary.</p>

<p>If the API is in early stage and not even yet consumed, you can break whatever you want without even thinking about it.
If the API is consumed only by a single application that you build yourself, you can most probably do it with not much work.
On the opposite, if the API is consumed by many consumers that are “far” from you, another team, another business unit or worse partners or customers.
The cost will be high.</p>

<p>The less consumers and the more you control them, the less will cost a breaking change. 
The more consumers and the less you control them, the more will cost a breaking change.</p>

<h1 id="how-to-avoid-it">How to avoid it</h1>

<p>Before requiring consumers to update their code, maybe you should think twice and find a way to avoid that.
Here are 3 ways to more or less “avoid” introducing breaking changes.</p>

<h2 id="dont-do-it">Don’t do it</h2>

<p>First, triple check that you actually desperately need to make this breaking change.
Evaluate the value it brings versus its cost.
You want to fix some mistake (like a typo or a terrible name) to make a perfectly clean API?
That’s nice but probably counter-productive, perfection is not of this world, especially in API design.
Live with it for the time being, you may be able to fix that when introducing actually awaited new features that your consumers will be totally crazy about.
In the meanwhile, you may try to limit problems by improving the documentation if that help.</p>

<h2 id="make-it-backward-compatible">Make it backward-compatible</h2>

<p>If there are good reason to introduce this change, maybe there’s a way to make it in a non-breaking way.
The usual strategy to do that is only to “add” in a clever way.</p>

<p>Instead of modifying an existing operation, you may simply add a new one.
Why not adding a <code>POST /administrators</code> instead of modifying <code>POST /users</code> to introduce the new administrator user type?</p>

<p>On the inputs, always add optional properties/parameters with default values.
Let’s say you have a “create user” features and want introduce different service level (regular vs gold).
Instead of required <code>serviceLevel</code> that will hold <code>regular</code> or <code>gold</code>, set it optional with <code>regular</code> as default value.</p>

<p>On the output, just add, it doesn’t really matter if the new data is always returned or not.
You had a <code>isAdmin</code> property and want to manage more type of user like admin, moderator or whatever</p>

<p>There’s more often than not a way to turn a backward-incompatible change into a backward-compatible one, it may not lead to the best design but sometimes you have to make compromise.</p>

<h2 id="use-breaking-change-proof-design">Use breaking change proof design</h2>

<p>The third way to avoid breaking change is a little bit different: it’s about to ensure that breaking changes have less risk to happen by choosing a breaking change proof design.</p>

<p>You can work on data types, avoid using booleans or arrays of atomic (string, number, …) for instance.
A <code>isAdmin</code> property is less extensible than a <code>role: "admin"</code> one, indeed, there may be more roles than admin and non admin users in the future.
Which is less extensible than a <code>roles: ["admin"]</code>, because a user may have more than one role in the future.
Which is less extensible than a <code>roles: [{ type: "admin"}]</code>, because a role may need more features such as a start and end date for example.</p>

<p>You can work building self sufficient features by adding data or new operations.
When accessing a user, consumer may need to know what their role mean, at the beginning they can hardcode that an admin user can do everything while a non admin one can only read data for example.
But if you provide the role description along with its type, you may seamlessly introduce new user types.
When creating a user, consumer need to know the available types of user they can create, they can hardcode that based on an enumeration provided in your documentation or they could call a <code>GET /userTypes</code> and get up to date data.</p>

<p>And last but not least, you can also lessen the risk of breaking changes by hiding as much as possible what happens inside your API, inside your domain.
The less the outside world know about your internal business rules and way of working, the less coupled with consumers you’ll be.</p>

<h1 id="how-to-handle-it">How to handle it</h1>

<p>Here a few good practice and tips if there are absolutely no way to avoid the breaking changes.
And note that it WILL happen, either because you must implement this new killer feature for yesterday or because the current version has live long enough and you definite</p>

<h2 id="synchronized-modifications">Synchronized modifications</h2>

<h2 id="wait-for-the-right-moment-and-introduce-a-new-api">Wait for the right moment and introduce a new API</h2>

<p>A corollary to the “make it backward compatible even that is not totally clean” strategy is to wait for the right moment.
I always recommend to the team I work with to create their API, let it live and evolve possibly introducing API design compromises.
Then after a while, once they have sufficient experience with the domain of the API and if there’s a killer new feature to introduce, that’s the right moment to clean all this mess and break everything.</p>

<h2 id="include-that-in-your-terms-of-services">Include that in your terms of services</h2>
:ET